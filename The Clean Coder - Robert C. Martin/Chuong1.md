# Professionalism 
> “Ồ cười đi, Curtin, cậu bé. Đó là một trò đùa tuyệt vời của Chúa, hoặc số phận, hoặc tạo hóa, 
> bất cứ điều gì cậu thích. Nhưng bất cứ ai hay bất cứ điều gì chơi đùa với điều đó chắc chắn 
> có một khiếu hài hước! Ha! ”
    - Howard, Kho báu của Sierra Madre
## Chương I: Professionalism
Vậy bạn muốn trở thành một nhà phát triển phần mềm chuyên nghiệp? Bạn muốn ngẩng cao đầu và tuyên bố 
với cả thế giới rằng: "Tôi là người chuyên nghiệp!" Bạn muốn mọi người nhìn bạn với sự tôn trọng và 
đối đãi với bạn một cách tôn trọng. Bạn muốn các bà mẹ chỉ vào bạn và nói rằng những đứa con của họ giống bạn. 
Bạn muốn tất cả. Đúng chứ?
### Hãy cẩn thận với những gì bạn hỏi
Chuyên gia là một thuật ngữ nặng nề. Chắc chắn đó là một huy chương của danh dự và niềm kiêu hãnh, nhưng nó cũng là dấu hiệu của trách nhiệm và nhiệm vụ giải trình. Tất nhiên là hai điều đó đi cùng nhau. Bạn không thể tự hào và vinh dự về một điều gì đó mà bạn không thể chịu trách nhiệm.
Để trở thành một người không chuyên nghiệp dễ dàng hơn nhiều. Những người không chuyên nghiệp không cần phải có
trách nhiệm đối với công việc họ làm - họ giao điều đó cho nhà tuyển dụng. Nếu một người thiếu chuyên nghiệp mắc một lỗi, nhà tuyển dụng sẽ dọn dẹp đống lộn xộn đó. Nhưng khi một người chuyên nghiệp mắc lỗi, anh ta tự mình giải quyết nó.
Điều gì sẽ xảy ra nếu bạn bỏ qua một lỗi tồn tại trong một mô-đun và công ty bạn phải trả chi phí $10.000? 
Người không chuyên nghiệp sẽ nhún vai, nói
"Mọi thứ sẽ xảy ra" và bắt đầu viết mô-đun tiếp theo. Chuyên gia sẽ viết cho công ty một tấm séc $10.000!

Chà, cảm giác hơi khác khi đó là tiền của chính bạn, phải không? Nhưng cảm giác đó là cảm giác mà một người chuyên nghiệp luôn có. Thật vậy, đó là cảm giác bản chất của sự chuyên nghiệp. Bởi vì, như bạn thấy, sự chuyên nghiệp là tất cả về trách nhiệm công việc.

## CHỊU TRÁCH NHIỆM
Bạn đã đọc phần giới thiệu, phải không? Nếu không, hãy quay lại và làm ngay lập tức; nó đặt bối cảnh cho mọi thứ tiếp theo trong cuốn sách này.
Tôi đã học được cách chịu trách nhiệm bằng cách gánh chịu hậu quả của việc không chịu trách nhiệm.

Năm 1979, tôi đang làm việc cho một công ty tên là Teradyne. Tôi là "kỹ sư chịu trách nhiệm" cho phần mềm điều khiển một hệ thống dựa trên máy tính nhỏ và vi mô để đo chất lượng đường dây điện thoại. Máy tính mini trung tâm được kết nối qua đường dây điện thoại quay số hoặc chuyên dụng 300-baud với hàng chục máy vi tính vệ tinh điều khiển phần cứng đo lường. Tất cả code đều được viết bằng trình hợp ngữ. 
Khách hàng của chúng tôi là giám đốc dịch vụ của các công ty điện thoại lớn. Mỗi công ty chịu trách nhiệm cho 100.000 đường dây điện thoại hoặc hơn. Hệ thống của tôi đã giúp những người quản lý khu vực dịch vụ này tìm và sửa chữa các trục trặc và sự cố trong đường dây điện thoại trước khi khách hàng của họ nhận ra. Điều này làm giảm tỷ lệ phàn nàn của khách hàng mà các khoản hoa hồng công ích đo lường và sử dụng để điều chỉnh mức giá mà các công ty điện thoại có thể tính. Tóm lại, những hệ thống này cực kỳ quan trọng. 
Hàng đêm, các hệ thống này chạy theo một “quy trình hàng đêm”, trong đó máy tính mini trung tâm ra lệnh cho mỗi máy vi tính vệ tinh kiểm tra mọi đường dây điện thoại dưới sự kiểm soát của chúng. Mỗi buổi sáng, máy tính trung tâm sẽ kéo lại danh sách các đường bị lỗi, cùng với các đặc điểm lỗi của chúng. Người quản lý khu vực kinh doanh sẽ sử dụng báo cáo này để lên lịch cho thợ sửa chữa lỗi trước khi khách hàng có thể khiếu nại.
Vào một dịp, tôi đã gửi một bản phát hành mới cho vài chục khách hàng. "Ship" là từ chính xác. Tôi đã viết phần mềm lên băng và chuyển những băng đó cho khách hàng. Các khách hàng đã tải băng và sau đó khởi động lại hệ thống.
Bản phát hành mới đã sửa một số lỗi nhỏ và được thêm một tính năng mới mà khách hàng của chúng tôi yêu cầu. Chúng tôi đã nói với họ rằng chúng tôi sẽ cung cấp tính năng mới đó vào một ngày nhất định. Tôi hầu như không quản lý được băng qua đêm để chúng đến đúng ngày đã hẹn. Hai ngày sau, tôi nhận được cuộc gọi từ người quản lý dịch vụ hiện trường của chúng tôi, Tom. Anh ấy nói với tôi rằng một số khách hàng đã phàn nàn rằng “quy trình hàng đêm” chưa hoàn thành và họ không nhận được báo cáo nào. Trái tim tôi trùng xuống vì để giao
phần mềm đúng hẹn, tôi đã bỏ bê để kiểm tra các quy trình. Tôi đã thử nghiệm nhiều chức năng khác của hệ thống, nhưng việc thử nghiệm quy trình này mất hàng giờ và tôi cần giao phần mềm. Không có bản sửa lỗi nào trong code, vì vậy tôi cảm thấy an toàn.
Mất một báo cáo hàng đêm là một việc lớn. Nó có nghĩa là thợ sửa chữa ít phải làm hơn và sẽ được đặt trước quá nhiều sau đó. Nó có nghĩa là một số khách hàng có thể nhận thấy lỗi và khiếu nại. Mất dữ liệu trong một đêm là đủ để người quản lý khu vực kinh doanh gọi Tom đến và thịt :) anh ta.
Tôi khởi động hệ thống phòng thí nghiệm của mình, tải phần mềm mới và sau đó bắt đầu một quy trình. Nó đã mất vài giờ nhưng sau đó nó bị hủy bỏ. Quy trình không thành công. Nếu tôi chạy thử nghiệm này trước khi giao hàng, các khu vực kinh doanh sẽ không bị mất dữ liệu và những người quản lý khu vực kinh doanh sẽ không quản lý Tom.
Tôi gọi cho Tom để nói với anh ấy rằng tôi có thể trùng lặp vấn đề. Anh ấy nói với tôi rằng hầu hết các khách hàng khác đã gọi cho anh ấy với cùng một lời phàn nàn. Sau đó anh ấy hỏi tôi khi nào tôi có thể sửa chữa nó. Tôi đã nói với anh ấy rằng tôi không biết, nhưng tôi đã làm việc với nó.

Sau khi phản ánh, tôi nhận ra rằng việc giao mà không kiểm tra quy trình là vô trách nhiệm. Lý do tôi bỏ qua bài kiểm tra là vì vậy tôi có thể nói rằng tôi đã vận chuyển HOÀN TOÀN, KHÔNG GÂY HẠI
 Đó là về việc tôi giữ thể diện. Tôi đã không quan tâm đến khách hàng, cũng như về chủ nhân của tôi. Tôi chỉ quan tâm đến danh tiếng của mình. Lẽ ra, tôi nên nhận trách nhiệm sớm và nói với Tom rằng các bài kiểm tra chưa hoàn thành và tôi chưa chuẩn bị để giao phần mềm đúng hạn. Cái đó
sẽ rất khó, và Tom sẽ rất buồn. Nhưng sẽ không có khách hàng nào bị mất dữ liệu và cũng không có người quản lý dịch vụ nào gọi đến.

### ĐẦU TIÊN KHÔNG GÂY HẠI
Vậy chúng ta phải chịu trách nhiệm như thế nào? Có một số nguyên tắc. Rút ra từ lời thề Hippocrate có vẻ kiêu ngạo, nhưng còn nguồn nào tốt hơn? Và, thực sự, có phải trách nhiệm đầu tiên và mục tiêu đầu tiên của một chuyên gia đầy khát vọng là sử dụng quyền hạn của mình cho mục đích tốt không?
Một nhà phát triển phần mềm có thể gây hại gì? Từ quan điểm phần mềm thuần túy, người đó có thể gây hại cho cả chức năng và cấu trúc của phần mềm. Chúng ta sẽ khám phá cách tránh làm điều đó.

### DO NO HARM TO FUNCTION
Rõ ràng, chúng tôi muốn phần mềm của mình hoạt động. Thật vậy, hầu hết chúng ta là lập trình viên ngày nay bởi vì chúng ta có một thứ gì đó để làm việc một lần và chúng ta muốn cảm giác đó một lần nữa.
Nhưng chúng tôi không phải là những người duy nhất muốn phần mềm hoạt động. Khách hàng và nhà tuyển dụng của chúng tôi cũng muốn nó hoạt động. Thật vậy, họ đang trả tiền cho chúng tôi để tạo ra phần mềm hoạt động theo cách họ muốn.
Chúng tôi làm hại chức năng của phần mềm khi chúng tôi tạo ra lỗi. **Vì vậy, để trở nên chuyên nghiệp, chúng ta không được tạo ra lỗi.**
"Nhưng chờ đã!" Tôi nghe bạn nói. “Điều đó không hợp lý. Phần mềm quá phức tạp để tạo ra mà không có lỗi ”.
Tất nhiên bạn có quyền. Phần mềm quá phức tạp để tạo ra mà không có lỗi. Thật không may, điều đó không cho phép bạn thành công. Cơ thể con người quá phức tạp để có thể hiểu được toàn bộ, nhưng các bác sĩ vẫn tuyên thệ không làm tổn hại gì. Nếu họ không tự cởi ra như vậy, làm sao chúng ta có thể? 
"Bạn đang nói với chúng tôi rằng chúng tôi phải hoàn hảo?" Tôi có nghe bạn phản đối không?
Không, tôi đang nói với bạn rằng **bạn phải chịu trách nhiệm cho sự không hoàn hảo của mình**. Thực tế là lỗi chắc chắn sẽ xảy ra trong code của bạn không có nghĩa là bạn không chịu trách nhiệm về chúng. Thực tế là nhiệm vụ viết phần mềm hoàn hảo hầu như là không thể, không có nghĩa là bạn không phải chịu trách nhiệm về sự không hoàn hảo.
Rất nhiều người chuyên nghiệp phải chịu trách nhiệm cho các sai sót mặc dù các lỗi là hầu như chắc chắn. Vì vậy, tôi chuyên nghiệp, điều đầu tiên bạn phải thực hiện là xin lỗi. Lời xin lỗi là cần thiết, nhưng không đủ. Bạn không thể cứ lặp đi lặp lại những lỗi giống nhau. Khi bạn trưởng thành trong nghề, tỷ lệ lỗi của bạn sẽ nhanh chóng giảm dần về phía tiệm cận bằng không. Nó sẽ không bao giờ về 0, nhưng bạn có trách nhiệm phải tiến gần nhất có thể.
### QA should find nothing

Do đó, khi bạn phát hành phần mềm của mình, bạn nên mong đợi QA không tìm thấy vấn đề gì. Việc cố tình gửi mã mà bạn biết là bị lỗi cho QA là không chuyên nghiệp. ***Và bạn biết mã nào bị lỗi? Bất kỳ mã nào bạn không chắc chắn về nó!***
Một số người sử dụng QA làm công cụ bắt lỗi. Họ gửi cho họ mã mà họ chưa kiểm tra kỹ lưỡng. Họ phụ thuộc vào QA để tìm lỗi và báo cáo lại cho nhà phát triển. Thật vậy, một số công ty thưởng QA dựa trên số lượng lỗi mà họ tìm thấy. Càng nhiều lỗi, phần thưởng càng lớn.
Đừng bận tâm rằng đây là một hành vi cực kỳ tốn kém gây thiệt hại cho công ty và phần mềm. Đừng bận tâm rằng hành vi này làm hỏng lịch trình và làm suy giảm niềm tin của doanh nghiệp vào nhóm phát triển. Đừng bận tâm rằng hành vi này chỉ đơn giản là lười biếng và vô trách nhiệm. Phát hành mã cho QA
mà bạn không biết rằng công việc là không chuyên nghiệp. Nó vi phạm quy tắc "không gây hại". QA sẽ tìm ra lỗi? Có thể, vì vậy, hãy sẵn sàng xin lỗi — và sau đó tìm hiểu lý do tại sao những lỗi đó cố gắng thoát khỏi thông báo của bạn và làm điều gì đó để ngăn nó xảy ra lần nữa. Mỗi khi QA, hoặc tệ hơn là người dùng phát hiện ra vấn đề, bạn sẽ phải ngạc nhiên,
kinh hãi, và quyết tâm ngăn chặn điều đó xảy ra lần nữa.
Bạn phải biết nó hoạt động
**Làm thế nào bạn có thể biết mã của bạn hoạt động?** Thật dễ dàng. Kiểm tra nó. Kiểm tra nó một lần nữa. Kiểm tra nó lên. Kiểm tra nó xuống. Kiểm tra nó bảy cách đến Chủ nhật!
để được thực thi. Nếu bạn mong đợi nó được thực thi, bạn phải biết rằng nó hoạt động. Cách duy nhất để biết điều này là kiểm tra nó.
Tôi là người đóng góp và cam kết chính cho một dự án nguồn mở có tên FitNesse. Khi viết bài này, có 60ksloc trong FitNesse. 26 trong số 60 được viết
trong hơn 2000 bài kiểm tra đơn vị. Emma báo cáo rằng tỷ lệ bao phủ của 2000 bài kiểm tra đó là ~ 90%.
Tại sao độ phủ mã của tôi không cao hơn? Bởi vì Emma không thể nhìn thấy tất cả các dòng mã đang được thực thi! Tôi tin rằng độ phủ cao hơn thế nhiều. Có phải là 100% không? Không, 100% là một đường tiệm cận.
**Nhưng có phải một số mã khó kiểm tra không?** Có, nhưng chỉ vì mã đó đã được thiết kế để khó kiểm tra. Giải pháp cho điều đó là thiết kế mã của bạn để dễ kiểm tra. Và cách tốt nhất để làm điều đó là viết các bài kiểm tra của bạn trước, trước khi bạn viết mã vượt qua chúng.

Có lẽ bạn lo ngại rằng việc kiểm tra mã của bạn quá nhiều sẽ mất quá nhiều thời gian. Sau tất cả, bạn đã có lịch trình và thời hạn. Nếu bạn dành toàn bộ thời gian để thử nghiệm, bạn sẽ không bao giờ viết được bất kỳ điều gì khác. Tốt! Vì vậy, hãy tự động hóa các bài kiểm tra của bạn. Viết các bài kiểm tra đơn vị mà bạn có thể thực hiện khi có thông báo trong chốc lát và chạy
những bài kiểm tra đó thường xuyên nhất có thể.
**Bao nhiêu code nên được kiểm tra với các bài kiểm tra tự động này?** Tôi có thực sự cần phải trả lời câu hỏi đó không? Tất cả! 
Tôi có đề xuất phạm vi kiểm tra 100% không? Không, tôi không đề xuất nó. Tôi đang đòi hỏi nó. **Mỗi dòng mã bạn viết phải được kiểm tra.** Giai đoạn = Stage. Đó không phải là không thực tế? Dĩ nhiên là không. Bạn chỉ viết mã vì bạn mong đợi Đây là một kỷ luật được gọi là Phát triển theo hướng kiểm tra (TDD), mà chúng ta sẽ nói rõ hơn trong chương sau.

### QA tự động
Toàn bộ quy trình QA cho FitNesse là việc thực hiện đơn vị và kiểm tra chấp nhận. Nếu vượt qua những bài kiểm tra đó, tôi xuất xưởng. Điều này có nghĩa là thủ tục QA của tôi mất khoảng ba phút và tôi có thể thực hiện nó tùy ý.
Hiện tại, đúng là không ai chết nếu có lỗi trong FitNesse. Cũng không ai mất hàng triệu đô la. Mặt khác, FitNesse có hàng nghìn người dùng và một danh sách lỗi rất nhỏ.
Chắc chắn một số hệ thống có nhiệm vụ quan trọng đến mức không đủ để xác định mức độ sẵn sàng triển khai. Mặt khác, bạn với tư cách là nhà phát triển cần một cơ chế tương đối nhanh chóng và đáng tin cậy để biết rằng mã bạn đã viết hoạt động và không can thiệp vào phần còn lại của hệ thống. Vì vậy, ít nhất, các bài kiểm tra tự động của bạn sẽ cho bạn biết rằng hệ thống rất có khả năng vượt qua QA.

## DO NO HARM TO STRUCTURE
Một chuyên gia thực sự biết rằng việc cung cấp chức năng mà không cần đến cấu trúc là một việc vặt vãnh. **Chính cấu trúc code của bạn cho phép nó linh hoạt.** Nếu bạn thỏa hiệp với cấu trúc, bạn sẽ thỏa hiệp với tương lai.
Giả định cơ bản của tất cả các dự án phần mềm là phần mềm dễ thay đổi. Nếu bạn vi phạm giả định này bằng cách tạo ra các cấu trúc không linh hoạt, thì bạn đã cắt xén mô hình kinh tế mà toàn bộ ngành công nghiệp dựa trên nó.
Tóm lại: Bạn phải có khả năng thực hiện các thay đổi mà không phải trả phí cắt cổ.
Thật không may, tất cả quá nhiều dự án trở thành sa lầy trong một hố hắc ín với ***cấu trúc kém***. Các công việc thường mất nhiều ngày bắt đầu mất vài tuần, sau đó là vài tháng. Ban quản lý, với mong muốn lấy lại động lực đã mất, đã thuê nhiều nhà phát triển hơn để đẩy nhanh tiến độ. Nhưng những nhà phát triển này chỉ đơn giản là thêm vào morass, làm sâu sắc thêm thiệt hại về cấu trúc và nâng cao trở ngại.
Phần lớn đã được viết về các nguyên tắc và mẫu thiết kế phần mềm hỗ trợ các cấu trúc linh hoạt và có thể bảo trì được.
Các nhà phát triển phần mềm chuyên nghiệp cam kết những điều này vào bộ nhớ và cố gắng để phần mềm của họ phù hợp với chúng. Nhưng có một mẹo nhỏ cho điều này mà quá ít nhà phát triển phần mềm làm theo: Nếu bạn muốn phần mềm của mình linh hoạt, bạn phải linh hoạt nó!
Cách duy nhất để chứng minh rằng phần mềm của bạn dễ thay đổi là thực hiện các thay đổi dễ dàng đối với nó. Và khi bạn nhận thấy rằng các thay đổi không dễ dàng như bạn nghĩ, bạn sẽ tinh chỉnh thiết kế để thay đổi tiếp theo dễ dàng hơn.
Khi nào bạn thực hiện những thay đổi dễ dàng này? Mọi lúc! Mỗi khi bạn nhìn vào một mô-đun, bạn thực hiện những thay đổi nhỏ, nhẹ cho nó để cải thiện cấu trúc của nó.
Mỗi khi bạn đọc qua mã, bạn sẽ điều chỉnh cấu trúc.
Triết lý này đôi khi được gọi là tái cấu trúc không thương tiếc. Tôi gọi đó là “quy tắc Hướng đạo sinh”: Luôn luôn kiểm tra một mô-đun sạch hơn khi bạn kiểm tra nó. ***Luôn thực hiện một số hành động tử tế ngẫu nhiên với mã bất cứ khi nào bạn nhìn thấy nó.***
Điều này hoàn toàn trái ngược với cách mà hầu hết mọi người nghĩ về phần mềm. Họ cho rằng việc thực hiện một loạt thay đổi liên tục đối với phần mềm đang hoạt động là rất nguy hiểm. Không! Điều nguy hiểm là cho phép phần mềm ở trạng thái tĩnh. Nếu bạn không uốn cong nó, thì khi bạn cần thay đổi nó, bạn sẽ thấy nó cứng nhắc.
***Tại sao hầu hết các nhà phát triển sợ thực hiện các thay đổi liên tục đối với mã của họ? Họ sợ rằng họ sẽ phá vỡ nó! Tại sao họ sợ họ sẽ phá vỡ nó? Bởi vì họ không có bài kiểm tra.***
Tất cả trở lại với các bài kiểm tra. Nếu bạn có một bộ kiểm tra tự động bao gồm gần như 100% mã và nếu bộ kiểm tra đó có thể được thực thi nhanh chóng theo ý thích, thì bạn sẽ không ngại thay đổi mã. Làm thế nào để bạn chứng minh rằng bạn không sợ thay đổi mã? Bạn thay đổi nó mọi lúc.
Các nhà phát triển chuyên nghiệp rất chắc chắn về mã và các thử nghiệm của họ, đến nỗi họ rất bình thường về việc thực hiện các thay đổi ngẫu nhiên, mang tính cơ hội. Họ sẽ thay đổi tên của một lớp học, tùy theo ý thích. Họ sẽ nhận thấy một phương pháp dài hạn trong khi đọc qua một mô-đun và phân vùng lại nó như một điều tất nhiên. Họ sẽ biến đổi một câu lệnh switch thành triển khai đa hình hoặc thu gọn hệ thống phân cấp kế thừa thành một chuỗi lệnh. Nói tóm lại, họ xử lý phần mềm như cách một nhà điêu khắc xử lý đất sét — họ liên tục tạo hình và nhào nặn nó.

### ĐẠO ĐỨC LÀM VIỆC
Sự nghiệp của bạn là trách nhiệm của bạn. Chủ nhân của bạn không có trách nhiệm đảm bảo rằng bạn có thể tiếp thị được. Chủ nhân của bạn không có trách nhiệm đào tạo bạn, đưa bạn đến các hội nghị, hoặc mua sách cho bạn. Những điều này là trách nhiệm của bạn. Khốn cho nhà phát triển phần mềm, người giao phó sự nghiệp của mình cho người chủ của mình.
Một số nhà tuyển dụng sẵn sàng mua sách cho bạn và gửi bạn đến các lớp đào tạo và hội nghị. Tốt thôi, họ đang giúp đỡ bạn. Nhưng đừng bao giờ rơi vào bẫy khi nghĩ rằng đây là trách nhiệm chủ nhân của bạn. Nếu chủ nhân của bạn không làm những điều này cho bạn, bạn nên tự tìm cách thực hiện chúng.
Chủ nhân của bạn cũng không có trách nhiệm phải cho bạn thời gian bạn cần để học hỏi. Một số nhà tuyển dụng có thể cung cấp thời gian đó. Một số nhà tuyển dụng thậm chí có thể yêu cầu bạn dành thời gian. Nhưng một lần nữa, họ đang giúp đỡ bạn và bạn nên được đánh giá cao. Những ưu ái như vậy không phải là điều bạn nên mong đợi.
Bạn nợ chủ nhân của mình một khoảng thời gian và công sức nhất định. Để tranh luận, hãy sử dụng tiêu chuẩn của Hoa Kỳ là 40 giờ mỗi tuần. 40 giờ này nên được dành cho các vấn đề của chủ nhân của bạn, không phải cho các vấn đề của bạn.
Bạn nên lập kế hoạch làm việc 60 giờ mỗi tuần. 40 đầu tiên dành cho chủ nhân của bạn. 20 suất còn lại dành cho bạn. Trong 20 giờ còn lại này, bạn nên ***đọc, thực hành, học hỏi*** và nếu không sẽ nâng cao sự nghiệp của mình. Tôi có thể nghe thấy bạn đang nghĩ: “Nhưng gia đình tôi thì sao? Còn cuộc sống của tôi thì sao? Tôi có phải hy sinh chúng cho chủ nhân của tôi không? ” Tôi không nói về tất cả thời gian rảnh của bạn ở đây. Tôi đang nói về 20 giờ làm thêm mỗi tuần. Đó là khoảng ba giờ mỗi ngày. *Nếu bạn sử dụng giờ ăn trưa của mình để đọc, nghe podcast trên đường đi làm và dành 90 phút mỗi ngày để học một ngôn ngữ mới, bạn sẽ có tất cả.*
Làm toán. Trong một tuần có 168 giờ. Cung cấp cho chủ nhân của bạn 40, và sự nghiệp của bạn khác 20. Điều đó để lại 108. Thêm 56 cho giấc ngủ để lại 52 cho mọi thứ khác.
Có lẽ bạn không muốn cam kết như vậy. Điều đó không sao cả, nhưng bạn không nên nghĩ mình là một người chuyên nghiệp. *Các chuyên gia dành thời gian chăm sóc cho nghề nghiệp của họ.*
Có lẽ bạn nghĩ rằng công việc nên làm ở nơi làm việc và bạn không nên mang nó về nhà. Tôi đồng ý! Bạn không nên làm việc cho chủ nhân của mình trong 20 giờ đó. Thay vào đó, bạn nên làm việc cho sự nghiệp của mình.
Đôi khi hai cái này thẳng hàng với nhau. Đôi khi công việc bạn làm cho chủ lại có lợi rất nhiều cho sự nghiệp của bạn. Trong trường hợp đó, dành khoảng 20 giờ đó là hợp lý. Nhưng hãy nhớ, 20 giờ đó dành cho
bạn. Chúng sẽ được sử dụng để làm cho bạn có giá trị hơn với tư cách là một chuyên gia.
Có lẽ bạn nghĩ rằng đây là một công thức để kiệt sức. Ngược lại, nó là một công thức để tránh kiệt sức. Có thể bạn đã trở thành một nhà phát triển phần mềm vì bạn đam mê phần mềm và mong muốn trở thành một chuyên gia được thúc đẩy bởi niềm đam mê đó. Trong 20 giờ đó, bạn nên làm những việc để củng cố niềm đam mê đó. 20 giờ đó sẽ rất vui!

### KNOW YOUR FIELD
Bạn có biết biểu đồ Nassi-Schneiderman là gì không? Nếu không, tai sao không? Bạn có biết sự khác biệt giữa máy Mealy và máy trạng thái Moore không? Bạn nên biết.
Bạn có thể viết một câu nhanh mà không cần tra cứu nó không? Bạn có biết thuật ngữ "Phân tích chuyển đổi" có nghĩa là gì không? Bạn có thể thực hiện phân rã chức năng với Sơ đồ luồng dữ liệu không? Thuật ngữ “Dữ liệu lang thang” có nghĩa là gì? Bạn đã nghe thuật ngữ “Conascence” chưa? Bảng Parnas là gì?
Vô số ý tưởng, kỷ luật, kỹ thuật, công cụ và thuật ngữ trang trí cho lĩnh vực của chúng tôi trong 50 năm qua. Bạn biết bao nhiêu trong số này? ***Nếu bạn muốn trở thành một người chuyên nghiệp, bạn nên biết một phần lớn của nó và không ngừng tăng kích thước của phần đó.***
Tại sao bạn nên biết những điều này? Rốt cuộc, không phải lĩnh vực của chúng ta đang tiến triển nhanh chóng đến mức tất cả những ý tưởng cũ này đã trở nên không còn phù hợp sao? Phần đầu tiên của truy vấn đó có vẻ rõ ràng trên bề mặt. Chắc chắn lĩnh vực của chúng tôi đang tiến triển và với một tốc độ dữ dội. Tuy nhiên, điều thú vị là sự tiến bộ đó ở nhiều khía cạnh ngoại vi. Đúng là chúng tôi không đợi 24 giờ để biên dịch quay vòng nữa. Đúng là chúng tôi viết các hệ thống có kích thước hàng gigabyte. Đúng là chúng tôi làm việc giữa một mạng lưới rộng khắp toàn cầu cung cấp quyền truy cập tức thì vào
thông tin. Mặt khác, chúng ta đang viết những câu lệnh if và while giống như những gì chúng ta đã viết cách đây 50 năm. Nhiều thứ đã thay đổi. Nhiều đã không. Phần thứ hai của truy vấn chắc chắn không đúng. Rất ít ý tưởng trong 50 năm qua trở nên không còn phù hợp. Một số đã bị loại, đó là sự thật. ***Khái niệm về phát triển thác nước chắc chắn đã bị phản đối. Nhưng điều đó không có nghĩa là chúng ta không nên biết nó là gì, và những điểm tốt và xấu của nó.***
Tuy nhiên, nhìn chung, phần lớn các ý tưởng khó giành được trong 50 năm qua vẫn có giá trị như ngày nay. Có lẽ bây giờ chúng còn có giá trị hơn. Hãy nhớ lời nguyền của Santayana: "Những người không thể nhớ quá khứ là
bị lên án là tái phạm ”.
Dưới đây là một danh sách tối thiểu về những thứ mà mọi chuyên gia phần mềm nên thông thạo:
• Mẫu thiết kế. Bạn phải có thể mô tả tất cả 24 mẫu trong sách GOF và có kiến ​​thức làm việc về nhiều mẫu trong sách POSA.
• Nguyên tắc thiết kế. Bạn nên biết các nguyên tắc SOLID và hiểu rõ về các nguyên tắc thành phần.
• Các phương pháp. Bạn nên hiểu XP, Scrum, Lean, Kanban, Waterfall,
Phân tích có cấu trúc và Thiết kế có cấu trúc.

Kỷ luật. Bạn nên thực hành TDD, Thiết kế hướng đối tượng, Lập trình có cấu trúc, Tích hợp liên tục và Lập trình theo cặp.
• Phần mềm: Bạn nên biết cách sử dụng: UML, DFDs, Biểu đồ cấu trúc, Petri Nets, Sơ đồ và Bảng chuyển đổi trạng thái, biểu đồ luồng và bảng quyết định.

### CONTINUOUS LEARNING
Tốc độ thay đổi điên cuồng trong ngành của chúng ta có nghĩa là các nhà phát triển phần mềm phải tiếp tục học hỏi nhiều thứ chỉ để theo kịp. Khốn cho những kiến ​​trúc sư ngừng viết mã — họ sẽ nhanh chóng thấy mình không liên quan. Khốn cho những lập trình viên ngừng học ngôn ngữ mới — họ sẽ nhìn ngành công nghiệp trôi qua. Khốn cho những nhà phát triển không học được các kỷ luật và kỹ thuật mới — các đồng nghiệp của họ sẽ nổi trội khi họ sa sút.
Bạn có đến thăm một bác sĩ không cập nhật các tạp chí y khoa không?
Bạn có thuê một luật sư thuế không tuân thủ các luật và tiền lệ thuế không? Tại sao nhà tuyển dụng nên thuê các nhà phát triển không cập nhật? Đọc sách, bài báo, blog, tweet. Đi dự hội nghị. Chuyển đến nhóm người dùng.
Tham gia đọc sách và học nhóm. Tìm hiểu những điều nằm ngoài vùng an toàn của bạn. Nếu bạn là một lập trình viên .NET, hãy học Java. Nếu bạn là một lập trình viên Java, hãy học Ruby. Nếu bạn là một lập trình viên C, hãy học Lisp. Nếu bạn muốn thực sự uốn cong bộ não của mình, hãy học Prolog và Forth!

### THỰC HÀNH
Chuyên gia họ thực hành. Các chuyên gia chân chính làm việc chăm chỉ để giữ cho các kỹ năng của họ luôn sắc bén và sẵn sàng. ***Chỉ đơn giản làm công việc hàng ngày của bạn và gọi đó là thực hành là chưa đủ.***
Làm công việc hàng ngày của bạn là hiệu suất, không phải luyện tập. Thực hành là khi bạn
đặc biệt thực hiện các kỹ năng của bạn ngoài việc thực hiện công việc với mục đích duy nhất là tinh chỉnh và nâng cao các kỹ năng đó.
Nó có thể có ý nghĩa gì đối với một nhà phát triển phần mềm khi họ thực hành? Thoạt nghe khái niệm này có vẻ vô lý. Nhưng hãy dừng lại và suy nghĩ một chút. Xem xét cách các nhạc sĩ thành thạo nghề của họ nó không phải bằng cách biểu diễn. Đó là bằng cách luyện tập. Và họ luyện tập như thế nào? Trong số những thứ khác, họ có các bài tập đặc biệt mà họ thực hiện. Cân và chỉnh sửa và chạy. Họ làm đi làm lại những việc này để đào tạo ngón tay và tâm trí của họ, và để duy trì sự thành thạo kỹ năng của họ.

***Vậy các nhà phát triển phần mềm có thể làm gì để thực hành?*** Có cả một chương trong cuốn sách này dành riêng cho các kỹ thuật thực hành khác nhau, vì vậy tôi sẽ không đi sâu vào chi tiết ở đây. Một kỹ thuật tôi sử dụng thường xuyên là lặp đi lặp lại các bài tập đơn giản như Trò chơi Bowling hoặc Yếu tố cơ bản. Tôi gọi những bài tập này là kata. Có rất nhiều kata như vậy để bạn lựa chọn.
Kata thường xuất hiện dưới dạng một bài toán lập trình đơn giản để giải, chẳng hạn như viết hàm tính các thừa số nguyên tố của một số nguyên. Mục đích của việc làm kata không phải là tìm ra cách giải quyết vấn đề; bạn biết làm thế nào để làm điều đó rồi. Mục đích của kata là rèn luyện các ngón tay và trí não của bạn.
Tôi sẽ thực hiện một hoặc hai bài kata mỗi ngày, thường là một phần để ổn định công việc. Tôi có thể làm được
bằng Java, hoặc bằng Ruby, hoặc bằng Clojure, hoặc bằng một số ngôn ngữ khác mà tôi muốn duy trì kỹ năng của mình. Tôi sẽ sử dụng kata để rèn giũa một kỹ năng cụ thể, chẳng hạn như giữ cho các ngón tay của tôi quen với việc nhấn phím tắt hoặc sử dụng một số cấu trúc lại.
Hãy coi kata như một bài tập khởi động 10 phút vào buổi sáng và 10 phút hạ nhiệt vào buổi tối.

### COLLABORATION
Cách tốt nhất thứ hai để học là cộng tác với những người khác. Các nhà phát triển phần mềm chuyên nghiệp nỗ lực đặc biệt để cùng nhau lập trình, cùng nhau thực hành, cùng nhau thiết kế và lập kế hoạch. Bằng cách đó, họ học hỏi được nhiều điều từ nhau và hoàn thành công việc nhanh hơn với ít lỗi hơn.
Điều này không có nghĩa là bạn phải dành 100% thời gian của mình để làm việc với những người khác. Thời gian ở một mình cũng rất quan trọng. Tôi rất thích ghép nối chương trình với những người khác, điều đó khiến tôi phát điên nếu thỉnh thoảng không thể tự mình thoát ra được.

### MENTORING
Cách tốt nhất để học là dạy. Không gì có thể đưa các dữ kiện và giá trị vào đầu bạn nhanh hơn và khó hơn việc phải truyền đạt chúng cho những người mà bạn có trách nhiệm. Vì vậy, lợi ích của việc giảng dạy là nghiêng về phía người giáo viên.
Tương tự như vậy, không có cách nào tốt hơn để đưa những người mới vào một tổ chức hơn là ngồi xuống với họ và chỉ cho họ những sợi dây. Các chuyên gia chịu trách nhiệm cá nhân trong việc kèm cặp đàn em. Họ sẽ không để cho một đàn em than vãn về việc không được giám sát.

### KNOW YOUR DOMAIN
Mọi chuyên gia phần mềm có trách nhiệm hiểu rõ lĩnh vực giải pháp mà họ đang lập trình. Nếu bạn đang viết một hệ thống kế toán, bạn nên biết lĩnh vực kế toán. Nếu bạn đang viết một ứng dụng du lịch, bạn nên biết ngành công nghiệp du lịch. Bạn không cần phải là một chuyên gia tên miền, nhưng bạn cần phải tham gia vào quá trình thẩm định hợp lý.
Khi bắt đầu một dự án trong một miền mới, hãy đọc một hoặc hai cuốn sách về chủ đề này. Phỏng vấn khách hàng và người dùng của bạn về nền tảng và khái niệm cơ bản của miền. Dành một chút thời gian với các chuyên gia và cố gắng hiểu các nguyên tắc và giá trị của họ.
Đó là loại hành vi thiếu chuyên nghiệp tồi tệ nhất nếu chỉ viết mã từ một thông số kỹ thuật mà không hiểu tại sao thông số đó lại có ý nghĩa đối với doanh nghiệp. Thay vào đó, bạn nên biết đủ về miền để có thể nhận ra và xử lý các lỗi đặc tả.
### IDENTIFY WITH YOUR EMPLOYER/CUSTOMER
Vấn đề của chủ nhân là vấn đề của bạn. Bạn cần hiểu những vấn đề đó là gì và hướng tới những giải pháp tốt nhất. Khi phát triển một hệ thống, bạn cần đặt mình vào vị trí của người sử dụng lao động và đảm bảo rằng các tính năng bạn đang phát triển thực sự đáp ứng được nhu cầu của người sử dụng lao động.
Rất dễ dàng để các nhà phát triển xác định với nhau. Bạn rất dễ rơi vào thái độ giữa chúng tôi và họ với chủ nhân của mình. Các chuyên gia tránh điều này bằng mọi giá.

### HUMILITY
Lập trình là một hành động sáng tạo. Khi chúng ta viết mã, chúng ta đang tạo ra thứ gì đó từ hư vô. Chúng tôi mạnh dạn áp đặt trật tự khi hỗn loạn. Chúng tôi tự tin chỉ huy, chi tiết một cách chính xác, các hành vi của một cỗ máy có thể gây ra thiệt hại khôn lường. Và vì vậy, lập trình là một hành động của sự kiêu ngạo tối cao.
Các chuyên gia biết họ kiêu ngạo và không khiêm tốn một cách sai lầm. Một người chuyên nghiệp biết công việc của mình và tự hào về công việc của mình. Một người chuyên nghiệp luôn tự tin vào khả năng của mình và chấp nhận rủi ro một cách táo bạo và có tính toán dựa trên sự tự tin đó. Một người chuyên nghiệp không rụt rè.
Tuy nhiên, một người chuyên nghiệp cũng biết rằng sẽ có lúc anh ta thất bại, tính toán rủi ro sai lầm, khả năng của anh ta sẽ thiếu hụt; anh ấy sẽ nhìn vào gương và thấy một kẻ ngốc kiêu ngạo đang mỉm cười lại với anh ấy.
Vì vậy, khi một người chuyên nghiệp thấy mình là người thích đùa, anh ta sẽ là người đầu tiên cười.
Anh ấy sẽ không bao giờ chế giễu người khác, nhưng sẽ chấp nhận sự chế giễu khi điều đó là xứng đáng và cười nhạo khi điều đó không đúng. Anh ta sẽ không hạ thấp người khác khi mắc sai lầm, bởi vì anh ta biết mình có thể là người tiếp theo thất bại. 😀 
Một người chuyên nghiệp hiểu rõ sự kiêu ngạo tối cao của anh ta, và rằng những người định mệnh cuối cùng sẽ nhận thấy và san bằng mục tiêu của họ. Khi mục tiêu đó kết nối, điều tốt nhất bạn có thể làm là nghe theo lời khuyên của Howard: Cười.